# 배열(Array)
- 삽입/삭제 : O(N)
- 탐색 : O(1)
  - random access(임의 접근)을 통해서 탐색이 빠름.
- C++에서는 size 변경 불가 -> 그리하여 백터 라이브러리를 많이 사용함.
- Python은 리스트를 사용함

```c++
// C++
int arr[4] = {10, 11, 12, 13};
arr[2] = 5;
```

```python
# Python
arr = [10, 11, 12, 13]
arr[2] = 5
```

# 벡터 Vector : 동적배열의 느낌임
- 삽입/삭제 : O(N)
- 탐색 : O(1)

```c++
vector<pair<int, int>> v;
v.push_back(make_pair(123, 456));
v.emplace_back(789, 987);
printf(" size: %d\n", v.size());
for (auto p : v) {
  printf("%d, %d\n", p.first, p.second);
}
```

```python
# 튜플 사용
v = []
v.append((123, 456))
v.append((789, 987))
print("size : " , len(v))
for p in v:
  print(p)
```

# 연결리스트 Linked List
- 삽입/삭제: O(1)
- 탐색 : O(N)
- 코딩테스트에서는 별로 안쓰이지만, 다른 자료구조들을 구현할 시 많이 사용한다.
- 임의 접근이 불가능 하다. 
  - 삽입/삭제가 많이 일어나는 경우에는 연결리스트를 사용하는 것이 좋다.
  - 파이썬 및 일부 언어에서는 제공하지 않는다.

```c++
List<int> l;
l.emplace_back(0);
l.emplace_back(1);
l.emplace_back(2);
l.emplace_front(3);
printf("size: %d\n", l.size());
for (auto i : l) {
  print("%d \n", i);
}
```

# 스택 Stack
- 삽입/삭제 : O(1)
- FILO : First In Last Out의 형태를 지님

``` c++
stack<int> s;
s.push(123);
s.push(456);
s.push(789);
printf("size: %d\n", s.size());
while(!s.empty()) {
  printf("%d\n", s.top());
  s.pop();
}
```

```python
# 파이썬의 경우에는 그냥 리스트로 처리함.
s = []
s.append(123)
s.append(456)
s.append(789)
print("size : ", len(s))
while len(s) > 0:
  print(s[-1])
  s.pop(-1)
```

# 큐(Queue)
- 삽입/삭제 : O(1)
- FIFO : First In First Out의 형태를 지님.

``` c++
queue<int> q;
q.push(123);
q.push(456);
q.push(789);
printf("size: %d\n", q.size());
while(!q.empty()) {
  printf("%d\n", q.front());
  s.pop();
}
```

```python
from queue from Queue
# thread-safe : 성능이 느림

q = Queue()
q.put(123)
q.put(234)
q.put(345)

while q:
  print(q.get())
```


```python
# queue의 상위호환의 자료구조임. (양방향 삽입/삭제가 가능한 자료구조형임) : Double-Ended Queue 임.
# 단, thread safe 하지 않음. 그러나, 코딩테스트에서 thread safe 한 문제를 요구하지 않음.
# 명령어는 append, appendleft, pop, popleft 등이 존재하며 queue보다 더 편리하게 사용할 수 있음.
from collections import deque

q = deque()
q.append(123)
q.append(456)
q.append(789)
print("size : ", len(q))
while len(1) > 0:
  print(q.popleft())
```